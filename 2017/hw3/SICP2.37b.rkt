#lang racket
(define (number? exp)
  (if (pair? exp)
      #f
      (not (symbol? exp))))
(define (variable? exp)
  (if (pair? exp)#f
      (symbol? exp)))
(define (same-variable? exp var)
  (if (variable? exp)
      (eq? exp var)
      #f))
(define (search-loop op lst)
  (if (null? lst) lst
      (if (eq? (car lst) op)
           lst
          (search-loop op (cdr lst)))))
(define (cutexp old cutout)
  (if (eq? old cutout)
      '()
      (cons (car old) (cutexp (cdr old) cutout))))
(define (sum? exp)
  (if (pair? exp)
      (if (pair? (car exp))
          (sum? (cdr exp))
          (if (eq? (car exp) '+)#t
              (sum? (cdr exp))))
      #f))
(define (addend exp)(cutexp exp (search-loop '+ exp)))
(define (augend exp)(cdr (search-loop '+ exp)))
(define (make-sum add aug)
  (if (and (pair? add) (pair? aug))
      (cond ((eq? (car add) 0) aug)
            ((eq? (car aug) 0) add)
            (else (append add (list '+) aug)))
      (if (pair? add)
          (cond ((eq? aug 0) add)
                ((eq? (car add) 0)aug)
                (else (append add (list '+) (list aug))))
          (if (pair? aug)
              (cond ((eq? add 0) aug)
                    ((eq? (car aug) 0)add)
                    (else (append (list add) (list '+)  aug)))
              (if(and (number? add)(number? aug))
                 (+ add aug)
                 (list add '+ aug))))))
(define (product? exp)
  (if (pair? exp)
      (if (pair? (car exp))
          (product? (cdr exp))
          (if (eq? (car exp) '*)#t
              (product? (cdr exp))))
      #f))
(define (multiplier exp)(cutexp exp (search-loop '* exp)))
(define (multiplicand exp)(cdr (search-loop '* exp)))
(define (make-product plier plicand)
  (cond ((eq? (car plier) 1)
          (if (pair? (car plicand))
              plicand
              (car plicand))
         ((eq? (car plicand) 1)
          (if (pair? (car plier))
              plier
              (car plier)))
         ((eq? (car plier) 0) 0)
         ((eq? (car plicand) 0) 0)
         ((and (number? (car plier))
               (number? (car plicand)))
          (* (car plier)(car plicand)))
         (else (append plier (list '*) plicand)))))

;(define  x (read))
;(product? x)
;(make-product (multiplier x) (multiplicant x))
;(sum? x)
;(augend x)
;(addend x)
;(make-sum (addend x)(augend x))
(define (deriv exp var)
  (cond ((number? exp ) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        (else 
         (error "wrong format"))))

(define (myloop)
  (let ((a (read)))
    (if (eq? a eof)
        (void)
        (begin (display (deriv a 'x)) (newline) (myloop)))))
(define b (read))
(product? b)
(multiplier b)
(multiplicand b)
;(myloop)
;0
;x
;(x * 3)
;(y + x)
;(y * x)
;(x * x  + x * y)
;(x * x * x)
;(x * x * y)
;(x * x + x * x * y * (x + 3) + x * y)
