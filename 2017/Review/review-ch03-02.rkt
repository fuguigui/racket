#lang racket
;复习ch03-02 2017/6/14 8:40
;可改变序对的闭包实现
(define (cons x y)
  (define (set-x! v)(set! x v))
  (define (set-y! v)(set! y v))
  (define (dispatch m)
    (cond((eq? m 'car) x)
         ((eq? m 'cdr) y)
         ((eq? m 'set-car!) set-x!)
         ((eq? m 'set-cdr!) set-y!)
         (else(error "Undefined operation -- CONS" m))))
  dispatch)
(define (car v)(v 'car))
(define (cdr v)(v 'cdr))
(define (set-car! v x)((v 'set-car!) x) v)
(define (set-cdr! v y)((v 'set-cdr!) y) v)
;最后这个v是必要的，返回闭包，以便之后取cdr等操作
(set-cdr! (cons 4 5) 9)
(cdr (set-cdr! (cons 4 5) 9))

;队列的实现
(define (make-queue)
  (cons '() '()))
(define (front-ptr queue)(car queue))
(define (rear-ptr queue)(cdr queue))
(define (set-front-ptr! queue item)(set-car! queue item)queue)
(define (set-rear-ptr! queue item)(set-cdr! queue item) queue)
(define (empty-queue? queue)
  (null? (front-ptr queue)))
(define (insert! queue value)
  (let((newpair (cons value '())))
    (cond((empty-queue? queue)
          (set-front-ptr! queue newpair)
          (set-rear-ptr! queue newpair)queue)
    (else(set-cdr! (rear-ptr queue) newpair)
    (set-rear-ptr! queue newpair)
    queue))))
(define (delete! queue)
  (if(empty-queue? queue)
     ((error "DELETE! called with an empty queue")queue)
     (begin
      (set-front-ptr! queue
                      (cdr (front-ptr queue)))
      queue)))
(define (display-queue q)
  (define (loop ptr)
    (cond((eq? ptr (rear-ptr q))
          (display (car ptr))
          (newline))
         (else(begin
                (display (car ptr))
              (display " ")
              (set! ptr (cdr ptr))
              (loop ptr)))))
  (loop (front-ptr q)))
(define q (make-queue))
(insert! q 5)
(display-queue q)
(insert! q 6)
(display-queue q)
(insert! q 'c)
(display-queue q)
(delete! q)
(display-queue q)