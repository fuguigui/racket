#lang racket
(require (except-in r5rs eval))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((and? exp) (eval-and (operands exp) env))
        ((or? exp) (eval-or (operands exp) env))
        ((let? exp) (eval-let (operands exp) env))
        ((application? exp)
         (my-apply (actual-value (operator exp) env)
                   (operands exp)
                   env))
        (else
         (error "Unknown expression type -- EVAL" exp))))

;基本判断函数
(define (self-evaluating? exp)
 (cond ((number? exp) true)
 ((string? exp) true)
 (else false)))
(define (variable? exp) (symbol? exp))
(define (tagged-list? exp tag)
 (if (pair? exp)
     (eq? (car exp) tag)
     false))
(define (quoted? exp)
 (tagged-list? exp 'quote))
(define (and? exp)(tagged-list? exp 'and))
(define (or? exp) (tagged-list? exp 'or))
(define (let? exp) (tagged-list? exp 'let))
(define (assignment? exp)
 (tagged-list? exp 'set!))
(define (definition? exp)
 (tagged-list? exp 'define))
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (if? exp) (tagged-list? exp 'if))
(define (begin? exp) (tagged-list? exp 'begin))
(define (last-exp? seq) (null? (cdr seq)))
(define (cond? exp) (tagged-list? exp 'cond))
(define (application? exp) (pair? exp))


;基本取分支函数
(define (text-of-quotation exp) (cadr exp))

(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))

(define (definition-variable exp)
 (if (symbol? (cadr exp))
     (cadr exp) 
     (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)(cddr exp))))

(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp)) 
(define (make-lambda parameters body)
 (cons 'lambda (cons parameters body)))

(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
 (if (null? (cdddr exp))
     'false
     (cadddr exp)))
(define (make-if predicate consequent alternative)
  (if (null? consequent)
      (if (eq? alternative 'false)
          predicate
          (list 'begin predicate alternative))
      (list 'if predicate consequent alternative)))


(define (cond-clauses exp) (cdr exp))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond-else-clause? clause) (eq? (cond-predicate clause) 'else))
(define (cond->if exp)
 (expand-clauses (cond-clauses exp)))

(define (begin-actions exp) (cdr exp))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))


(define (expand-clauses clauses)
  (if (null? clauses)
      'false ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last -- COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))


(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-and parameters env)
 (define (inner-eval-and exp)
   (let((result (actual-value (car exp) env))
        (rest (cdr exp)))
     (if(false? result)
        result
        (if(null? rest)
           result
           (inner-eval-and rest)))))
  (inner-eval-and parameters))

(define (eval-or parameters env)
  (define (inner-eval-or exp)
   (let((result (actual-value (car exp) env))
        (rest (cdr exp)))
     (if (true? result)
         result
         (if(null? rest)
             result
            (inner-eval-or rest)))))
  (inner-eval-or parameters))
;let处理
(define (eval-let exp env)
  (define (vars-of-let exp)
    (map car (car exp)))
  (define (exps-of-let exp)
    (map (lambda (x)(eval (cadr x) env)) (car exp)))
  (let((vars (vars-of-let exp))
       (exps (exps-of-let exp))
       (body (cdr exp)))
    (eval-sequence body (extend-environment vars exps env))))


(define (operator exp) (car exp))
(define (operands exp) (cdr exp))

(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))

(define (eval-assignment exp env)
 (set-variable-value!
  (assignment-variable exp)
  (eval (assignment-value exp) env)
   env)
  (void))
(define (eval-definition exp env)
  (define-variable!
    (definition-variable exp)
    (eval (definition-value exp) env)
    env)
  (void))
(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
(define (true? val)
  (not (false? val)))
(define (false? val)
  (eq? val 'false))
  
(define (make-procedure parameters body env)
 (list 'procedure parameters body env))
(define (compound-procedure? p)
 (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))

(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

;frame and environmnet
(define (make-frame variables values)
 (cons variables values))

(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
 (set-car! frame (cons var (car frame)))
 (set-cdr! frame (cons val (cdr frame))))
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))     
      (cons (make-frame vars
                        vals)
                        base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

;smart-lazy-variable
(define (get-vars var-list)
  (map (lambda (x)(if(pair? x)(car x) x)) var-list))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))

(define primitive-procedures
 (list  (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        (list 'number? number?)
        (list 'symbol? symbol?)
        (list 'eq? eq?)
        (list 'pair? pair?)
        (list 'not not)
        (list 'length length)
        (list 'cadr cadr)
        (list 'caddr caddr)
        (list 'cadddr cadddr)
        (list 'void void)
        (list 'list list)
        (list 'append append)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '> >)
        (list '< <)
        (list '= =)
        (list 'remainder remainder)
        (list 'display display)
        (list 'newline newline)
        (list 'sqrt sqrt)))

(define (primitive-procedure-names)
 (map car primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
  primitive-procedures))
(define (primitive-procedure? proc)
 (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))

(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
(define glb-env (setup-environment))

(define (my-apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (let ((tmp (list-of-arg-values arguments env)))
           (apply (primitive-implementation procedure) tmp)))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (get-vars (procedure-parameters procedure))
           (list-of-smart-delayed-args arguments (procedure-parameters procedure) env)
           (procedure-environment procedure))))
        (else
         (error "unkonwn procedure type -- APPLY" procedure))))

 (define (actual-value exp env)
   (force-it (eval exp env)))
(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
            (list-of-arg-values (rest-operands exps) env))))

(define (list-of-smart-delayed-args args vars env)
  (if (null? args)
      '()
      (let ((var (car vars))
            (arg (car args)))
        (cond ((null? var) '())
              ((pair? var)
               (cond ((eq? (cadr var) 'lazy)
                      (cons (delay-it-nomem arg env)
                            (list-of-smart-delayed-args (cdr args) (cdr vars) env)))
                     ((eq? (cadr var) 'lazy-memo)
                      (cons (delay-it-memo arg env)
                            (list-of-smart-delayed-args (cdr args) (cdr vars) env)))
                       (else (error "Invalid lazy-label: get-vals-according-to-var-label: " (cadr var)))))
              (else
               (cons (actual-value arg env)
                     (list-of-smart-delayed-args (cdr args) (cdr vars) env)))))))
  
(define (delay-it exp env)   (list 'thunk exp env))
(define (delay-it-nomem exp env) (list 'thunk-nomem exp env))
(define (delay-it-memo exp env) (list 'thunk-memo exp env))
(define (force-it obj)
 (cond ((or (thunk? obj) (thunk-memo? obj))
        (let ((result (actual-value (thunk-exp obj) (thunk-env obj))))
          (set-car! obj 'evaluated-thunk)
          (set-car! (cdr obj) result)
          (set-cdr! (cdr obj) '())
          result))
       ((thunk-nomem? obj) (actual-value (thunk-exp obj) (thunk-env obj)))
       ((evaluated-thunk? obj) (thunk-value obj))
       (else obj)))

(define (thunk? obj) (tagged-list? obj 'thunk))
(define (thunk-nomem? obj) (tagged-list? obj 'thunk-nomem))
(define (thunk-memo? obj) (tagged-list? obj 'thunk-memo))
(define (thunk-exp thunk) (cadr thunk)) 
(define (thunk-env thunk) (caddr thunk))
(define (evaluated-thunk? obj) 
  (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

(define (user-print object)
  (cond ((compound-procedure? object) (void))
        ((void? object) (void))        
        (else (display object) (newline))))

(define (myloop)
  (let ((a (read)))
    (if (eq? a eof)
        (void)
        (begin
          (user-print (actual-value a glb-env))
          (myloop)))))
(myloop)