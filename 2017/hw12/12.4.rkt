#lang racket
;(require (except-in r5rs eval))
;把执行和分析分离开
(require scheme/mpair)

(define (eval exp env)
  ((analyze exp)env))
(define (analyze exp)
  (cond((self-evaluating? exp) (analyze-self-evaluating exp))
       ((quoted? exp)(analyze-quoted exp))
       ((variable? exp)(analyze-variable exp))
       ((assignment? exp)(analyze-assignment exp))
       ((definition? exp)(analyze-definition exp))
       ((if? exp)(analyze-if exp))
       ((lambda? exp)(analyze-lambda exp))
       ((begin? exp)(analyze-sequence(begin-actions exp)))
       ((cond? exp)(analyze(cond->if exp)))
       ;这三个是新增的
       ((and? exp)(analyze-and exp))
       ((or? exp)(analyze-or exp))
       ((let? exp)(analyze-let exp))
       ((application? exp)(analyze-application exp))
       (else(error "Unknown expression type -- ANALYZE" exp))))

;基础操作判断函数
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
(define (variable? exp) (symbol? exp))
(define (quoted? exp)
  (tagged-list? exp 'quote))
(define (list-of-values lst env)
  (if (empty? lst) '()
      (cons (eval (car lst) env)
            (list-of-values (cdr lst) env))))
(define true #t)
(define false #f)
(define (false? x)
  (equal? x false))
(define (true? x)
  (not (false? x)))
;quote
(define (text-of-quotation exp) (cadr exp))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))

;set
(define (assignment? exp)
  (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


;define
(define (definition? exp)
  (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp) 
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp) 
                   (cddr exp)))) 


;lambda
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp)) 
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


;if
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

;begin
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))

(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

;cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause)
  (let ((action (cdr clause)))
    (if (null? action)
        (list (cond-predicate clause))
        action)))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))
(define (special-cond? exp)
  (eq? (cadr exp) '=>))
(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last -- COND->IF"
                       clauses))
            (if (special-cond? first)
                (make-if (cond-predicate first)
                         (list (sequence->exp (cddr first))
                               (cond-predicate first))
                         (expand-clauses rest))
                (make-if (cond-predicate first)
                     (sequence->exp (cond-actions  first))
                     (expand-clauses rest)))))))
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))


;application
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))

;new and/or/let
(define (and? exp)(tagged-list? exp 'and))
(define (or? exp)(tagged-list? exp 'or))
(define (let? exp)(tagged-list? exp 'let))

;procedure
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))

(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env) (eval-sequence (rest-exps exps) env))))

;analyze中的分支处理函数
;self-evaluating
(define (analyze-self-evaluating exp)
  (lambda (env) exp))
(define (analyze-quoted exp)
  (let((qval (text-of-quotation exp)))
    (lambda (env) qval)))
;variable
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (mcar vars))
             (mcar vals))
            (else (scan (mcdr vars) (mcdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame) (frame-values frame)))))
  (env-loop env))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (mcar vars))
             (set-mcar! vals val))
            (else (scan (mcdr vars) (mcdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (mcar vars))
             (set-mcar! vals val))
            (else (scan (mcdr vars) (mcdr vals)))))
    (scan (frame-variables frame) (frame-values frame))))

(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))
(define (analyze-assignment exp)
  (let((var (assignment-variable exp))
       (vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))
(define (analyze-if exp)
  (let((pproc (analyze (if-predicate exp)))
       (cproc (analyze (if-consequent exp)))
       (aproc (analyze (if-alternative exp))))
    (lambda (env)
      (if(true? (pproc env))
         (cproc env)
         (aproc env)))))
;and
(define (analyze-and exp)
  (let ((analyzed-pres (map analyze (cdr exp))))
    (define (inner-eval exp env)
      (let((result ((car exp) env))
           (rest (cdr exp)))
        (if (false? result)
            false
            (if (null? rest)
                result
                (inner-eval rest env)))))
    (lambda (env)(inner-eval analyzed-pres env))))
;or
(define (analyze-or exp)
  (let ((analyzed-pres (map analyze (cdr exp))))
    (define (inner-eval exp env)
      (let((result ((car exp) env))
           (rest (cdr exp)))
        (if (true? result)
            true
            (if (null? rest)
                result
                (inner-eval rest env)))))
    (lambda (env)(inner-eval analyzed-pres env))))
;let
(define (analyze-let exp)
  (let ((body (analyze(cons 'begin (cddr exp))))
        (vars-exps (cadr exp))
        (vars (mlist))
        (exps (mlist)))
    (map (lambda (x)
           (set! vars (mcons (car x) vars))
           (set! exps (mcons (analyze (cadr x)) exps)))
         vars-exps)
    (lambda (env) (body (extend-environment
                         vars
                         (mmap (lambda (exp)(exp env)) exps)
                         env)))))


(define (analyze-lambda exp)
  (let((vars (lambda-parameters exp))
       (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env)(make-procedure vars bproc env))))
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env)(proc1 env)(proc2 env)))
  (define(loop first-proc rest-procs)
    (if(null? rest-procs)
       first-proc
       (loop (sequentially first-proc (car rest-procs))
             (cdr rest-procs))))
  (let((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE")
        (void))
    (loop (car procs)(cdr procs))))
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application
       (fproc env)
       (map (lambda (aproc)(aproc env))aprocs)))))
(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply (primitive-implementation proc) args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
           (list->mlist(procedure-parameters proc))
           (list->mlist args)
           (procedure-environment proc))))
        (else(error "Unknown procedure type -- EXECUTE_APPLICATION" proc))))

;primitive-procedures
(define primitive-procedures 
  (mlist (list 'car car)
         (list 'cdr cdr)
         (list 'cons cons)
         (list 'null? null?)
         (list 'assoc assoc)
         (list 'number? number?)
         (list 'symbol? symbol?)
         (list 'eq? eq?)
         (list 'pair? pair?)
         (list 'not not)
         (list 'length length)
         (list 'cadr cadr)
         (list 'caddr caddr)
         (list 'cadddr cadddr)
         (list 'void void)
         (list 'list list)
         (list 'append append)
         (list '+ +)
         (list '- -)
         (list '* *)
         (list '/ /)
         (list '> >)
         (list '< <)
         (list '= =)
         (list 'remainder remainder)
         (list 'sqrt sqrt)))

(define (primitive-procedure-names)
  (mmap car
        primitive-procedures))
(define (primitive-procedure-objects)
  (mmap (lambda (proc) (list 'primitive (cadr proc))) primitive-procedures))
(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))

(define (my-apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply (primitive-implementation procedure) arguments))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (list->mlist (procedure-parameters procedure))
            (list->mlist arguments)
           (procedure-environment procedure))))
        (else
         (error "unkonwn procedure type -- APPLY" procedure))))



;frame和environmnet
;frame
(define (make-frame variables values)
  (mcons variables values))
(define (frame-variables frame) (mcar frame))
(define (frame-values frame) (mcdr frame))
(define (add-binding-to-frame! var val frame)
  (set-mcar! frame (mcons var (mcar frame)))
  (set-mcdr! frame (mcons val (mcdr frame))))
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment (list))

;environment
(define (extend-environment vars vals base-env)
  (if (= (mlength vars) (mlength vals))
      (cons (make-frame vars vals) base-env)
      (if (< (mlength vars) (mlength vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))

(define (setup-environment)
  (let ((initial-env (extend-environment (primitive-procedure-names) (primitive-procedure-objects) the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env) initial-env))

(define glb-env (setup-environment))


(define (driver-loop)
  (let((input (read)))
    (if(eq? input eof)
       (void)
       (let ((output (eval input glb-env)))
         (user-print output)
         (driver-loop)))))

(define (user-print object)
  (cond((equal? 'ok object) (void))
       ((compound-procedure? object)
        (display (list 'compound-procedure
                       (procedure-parameters object)
                       (procedure-body object)
                       '<procedure-env>))
        (newline))
       (else(display object)(newline))))
(driver-loop)