#lang racket
(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq) (accumulate op init (cdr seq)))))
(define (myor a b) (or a b))

(define (contains alist asymbol)
  (accumulate myor #f (map (lambda (s) (eq? s asymbol)) alist)))
(define (split-list alist asymbol)
  (if(eq? asymbol (car alist))
     (cons '() (cdr alist))
     (let((result (split-list (cdr alist) asymbol)))
       (cons
        (cons (car alist) (car result))
        (cdr result)))))
(define (single alist)
  (if(null? (cdr alist))
     (car alist)
     alist))

(define (variable? exp) (symbol? exp))
(define (same-variable? exp var) (eq? exp var))

(define (sum? exp)
  (cond((not(list? exp)) #f)
       ((contains exp '+) #t)
       (else #f)))
(define (product? exp)
  (cond((not(list? exp)) #f)
       ((contains exp '*) #t)
       (else #f)))

(define (make-sum exp1 exp2)
  (if(not(list? exp1))
     (set! exp1 (list exp1))
     void)
  (if(not(list? exp2))
     (set! exp2 (list exp2))
     void)
  (cond((equal? (list 0) exp1) (single exp2))
       ((equal? (list 0) exp2) (single exp1))
       (else (append exp1 (list '+) exp2))))
(define (make-product exp1 exp2)
  (if(not(list? exp1))
     (set! exp1 (list exp1))
     void)
  (if(not(list? exp2))
     (set! exp2 (list exp2))
     void)
  (cond((equal? (list 0) exp1) 0)
       ((equal? (list 0) exp2) 0)
       ((equal? (list 1) exp1) exp2)
       ((equal? (list 1) exp2) exp1)
       (else (list (single exp1) '* (single exp2)))))

(define (addend exp)
  (single (car (split-list exp '+))))
(define (augend exp)
  (single (cdr (split-list exp '+))))
(define (multiplicand exp)
  (single (cdr (split-list exp '*))))
(define (multiplier exp)
  (single (car (split-list exp '*))))


(define (deriv exp var)
  (cond ((number? exp ) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum 
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        (else 
         (error "wrong format"))))

(define (myloop)
  (let ((a (read)))
    (if (eq? a eof)
        (void)
        (begin (display (deriv a 'x)) (newline) (myloop)))))

(myloop)