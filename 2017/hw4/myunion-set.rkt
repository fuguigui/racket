#lang racket
(define (union-set set1 set2)
  (cond((null? set1) set2)
      ((null? set2) set1)
      (else(let((s1 (car set1))
                (s2 (car set2)))
             (cond((= s1 s2)(cons s1(union-set (cdr set1)(cdr set2))))
                  ((< s1 s2)(cons s1(union-set (cdr set1) set2)))
                  (else (cons s2 (union-set set1 (cdr set2)))))))))

(define (left tree)(cadr tree))
(define (right tree)(caddr tree))
(define (getvalue tree)(car tree))
(define (make-tree par left right)(list par left right))
(define (adjoin-tree value tree)
  (if (null? tree)(make-tree value '() '())
      (cond ((= value (getvalue tree))tree)
            ((< value (getvalue tree))
             (make-tree (getvalue tree)
                        (adjoin-tree value (left tree))
                        (right tree)))
            (else (make-tree (getvalue tree)
                             (left tree)
                             (adjoin-tree value (right tree)))))))
(define (list-to-tree lst)
  (if (null? lst)
      '()
      (adjoin-tree (car lst) (list-to-tree (cdr lst)))))
(define (tree-to-list tree)
  (if (null? tree)'()
      (append (tree-to-list (left tree))
              (list(getvalue tree))
              (tree-to-list (right tree)))))

(define (myloop)
  (define lst1 (read))
  (define lst2 (read))
  (if (eq? lst1 eof)
      (void)
      (begin (displayln(union-set (tree-to-list (list-to-tree lst1))
                 (tree-to-list (list-to-tree lst2))))
             (myloop))))
(myloop)